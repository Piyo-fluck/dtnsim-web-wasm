<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>dtnsim WASM demo</title>
  <style>body{margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial} #start-wasm{position:fixed;left:8px;bottom:8px;z-index:1000;padding:8px 12px} canvas{position:fixed;right:8px;bottom:8px;border:1px solid #444;z-index:999}</style>
</head>
<body>
  <button id="start-wasm">Start WASM demo</button>
  <div id="dtn-status" style="position:fixed;left:8px;bottom:48px;z-index:1000;color:#fff;background:#0008;padding:4px 6px;font-size:12px">status: idle</div>
  <canvas id="dtn-canvas" width="800" height="600" aria-label="dtnsim canvas"></canvas>

  <script src="dtnsim.js"></script>
  <script>
  // Use Emscripten factory pattern for WASM module
  let Module = null;
  function readNodePositionsMeta(Module) {
    if (!Module || typeof Module._dtnsim_get_node_positions !== 'function') throw new Error('WASM Module not initialized');
    const metaPtr = Module._dtnsim_get_node_positions(); // numeric pointer (0 if not available)
    if (!metaPtr) { throw new Error('dtnsim_get_node_positions returned 0'); }
    // Use Emscripten HEAPU8.buffer for memory
    const memBuffer = Module.HEAPU8?.buffer;
    if (!memBuffer) { throw new Error('No WASM HEAPU8 buffer found'); }
    const heap = Module.HEAPU8;
    if (heap.byteLength < metaPtr + 24) { throw new Error('Metadata out-of-bounds'); }
    const dv = new DataView(memBuffer, metaPtr, 24);
    return {
      positionsPtr: dv.getUint32(0, true),
      idsPtr: dv.getUint32(4, true),
      count: dv.getUint32(8, true),
      stride: dv.getUint32(12, true),
      version: dv.getUint32(16, true),
    };
  }

  function getPositionsFloatArray(Module, meta) {
    if (!meta || !meta.positionsPtr || meta.count === 0) return null;
    const memBuffer = Module.HEAPF32?.buffer;
    if (!memBuffer) { console.warn('No WASM HEAPF32 buffer found'); return null; }
    // HEAPF32 is always present after WASM init
    const elemOffset = meta.positionsPtr >>> 2; // byte -> float index
    const len = meta.count * 3;
    if ((elemOffset + len) > Module.HEAPF32.length) { console.warn('Positions buffer out-of-bounds'); return null; }
    return Module.HEAPF32.subarray(elemOffset, elemOffset + len);
  }

  (function setupDemo(){
    const btn = document.getElementById('start-wasm');
    const canvas = document.getElementById('dtn-canvas');
    const gl = canvas.getContext('webgl');
    if (!gl) { console.warn('WebGL unavailable'); btn.disabled = true; return; }

    function compileShader(type, src){ const s=gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){ console.error(gl.getShaderInfoLog(s)); return null; } return s; }
    const vs = `attribute vec3 a_pos; uniform vec2 u_center; uniform float u_scale; void main(){ vec2 p=(a_pos.xy - u_center) * u_scale; gl_Position = vec4(p,0.0,1.0); gl_PointSize = 3.0; }`;
    const fs = `precision mediump float; void main(){ gl_FragColor = vec4(0.0,0.6,1.0,1.0); }`;
    const prog = gl.createProgram(); const sv = compileShader(gl.VERTEX_SHADER, vs); const sf = compileShader(gl.FRAGMENT_SHADER, fs); gl.attachShader(prog, sv); gl.attachShader(prog, sf); gl.linkProgram(prog);
    if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){ console.error(gl.getProgramInfoLog(prog)); btn.disabled=true; return; }
    gl.useProgram(prog);
    const a_pos = gl.getAttribLocation(prog, 'a_pos'); const u_center = gl.getUniformLocation(prog, 'u_center'); const u_scale = gl.getUniformLocation(prog, 'u_scale');
    const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf); gl.enableVertexAttribArray(a_pos); gl.vertexAttribPointer(a_pos, 3, gl.FLOAT, false, 0, 0);

    let lastVersion = 0;
    btn.addEventListener('click', async () => {
      console.log('Start button clicked');
      if (!Module) {
        btn.disabled = true;
        btn.textContent = 'Loading WASM...';
        Module = await createDTNSIMModule();
        btn.textContent = 'Start WASM demo';
        btn.disabled = false;
        console.log('WASM module loaded');
      }

      function startWasmDemo() {
        console.log('WASM runtime initialized');
        // Debug: log HEAPU8/HEAPF32 objects
        console.log('Module.HEAPU8:', Module.HEAPU8);
        console.log('Module.HEAPF32:', Module.HEAPF32);

        // Initialize simulation (example: 100 agents)
        Module._dtnsim_init(100);
        console.log('dtnsim_init called');

        // Animation loop
        function frame() {
          try {
            console.log('frame called');
            console.log('Module keys:', Object.keys(Module));
            Module._dtnsim_step(0.016);
            const meta = readNodePositionsMeta(Module);
            console.log('meta:', meta);
            if (meta && meta.version !== lastVersion) {
              lastVersion = meta.version;
              const arr = getPositionsFloatArray(Module, meta);
              console.log('arr:', arr);
              if (arr && arr.length > 0) {
                gl.bindBuffer(gl.ARRAY_BUFFER, buf);
                gl.bufferData(gl.ARRAY_BUFFER, arr, gl.DYNAMIC_DRAW);
                // Center and scale
                let minx=1e9,maxx=-1e9,miny=1e9,maxy=-1e9;
                for(let i=0;i<arr.length;i+=3){
                  if(arr[i]<minx)minx=arr[i];if(arr[i]>maxx)maxx=arr[i];
                  if(arr[i+1]<miny)miny=arr[i+1];if(arr[i+1]>maxy)maxy=arr[i+1];
                }
                const cx=(minx+maxx)/2,cy=(miny+maxy)/2;
                const scale=2/Math.max(maxx-minx,maxy-miny,1);
                gl.uniform2f(u_center,cx,cy);
                gl.uniform1f(u_scale,scale);
                gl.clearColor(0.06, 0.07, 0.10, 1.0); // 適宜微調整
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.POINTS,0,arr.length/3);
              } else {
                console.warn('No positions to draw');
              }
            }
            requestAnimationFrame(frame);
          } catch (e) {
            console.error('WASM frame error:', e);
            const status = document.getElementById('dtn-status');
            if (status) status.textContent = 'WASM error: ' + e.message;
          }
        }
        requestAnimationFrame(frame);
      }

      // If runtime already initialized, start immediately
      if (Module.calledRun || Module._dtnsim_init) {
        startWasmDemo();
      } else {
        Module.onRuntimeInitialized = startWasmDemo;
      }
    });
  })();
    // ...existing code...
  </script>
</body>
</html>